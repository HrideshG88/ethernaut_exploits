# EXPLOIT CONTRACTS FOR ETHERNAUT
# LEVEL 0 hello_ethernaut

Level address
0x7E0f53981657345B31C59aC44e9c21631Ce710c7

player
"0x3A22d5B698CCb49b51B7B4D953a8Abb8F8a562cE"

player balance
"0.249167351766351369"

Instance address
0xE630e8733988736424AB5960972a70d0B12B3D9D

# LEVEL 1 fallback

Level address
0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB

player
"0x3A22d5B698CCb49b51B7B4D953a8Abb8F8a562cE"

player balance
"0.246686639705079244"

Instance address
0xd07Cd998cDA0D48Bc64147197A5e3178f04C15Ab

Owner Address
0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB

Send eth without data to hit `recieve` and bypass `contribute() require(msg.value < 0.001 ether);`

# LEVEL 2 fallout

Level address
0x676e57FdBbd8e5fE1A7A3f4Bb1296dAC880aa639

Instance address
0x140279Dfaa79ED222883d1D8829EC5c2dA716D48

player balance
"0.237886631459150539"

Send eth to fal1out function and become owner.
sollidity 0.6 constructor is declared by giving it same name as contract.
but fallout != fal1out
so fal1out is public payable and has no onlyowner + owner = msg.sender.

# LEVEL 3 coin_flip

Level address
0xA62fE5344FE62AdC1F356447B669E9E6D10abaaF

Instance address
0x596618416F79262706877209232c422256a54518

player balance
"0.221998662516445519"

copy function to exploit contract if true call coin_flip contract.
repeat till 10 consecutive wins.

# LEVEL 4 telephone

Level address
0x2C2307bb8824a0AbBf2CC7D76d8e63374D2f8446

Instance address
0x8EB725ce2951b4f03E45163A4E7eB5964144c0d4

player balance
"0.236519651586954841"

create a contract which calls changeowner on this contract.
profit!!!

# LEVEL 5 token

Level address
0x478f3476358Eb166Cb7adE4666d04fbdDB56C407

Instance address
0x9c13d7C9baB4CbD91128D995aB4AEfABD2Ea35a4

player balance
"0.49595465415281848"

simple overflow.

# LEVEL 6 delegation

Level address
0x73379d8B82Fda494ee59555f333DF7D44483fD58

Instance address
0x29f88f76fdAe722B4E49c09e662ACA1fF786e919

player balance
"0.487725355025665749"

delegate call missuse exploiting context. send 0xdd365b8b via low lvl transaction with your own acc.

# LEVEL 7 force

Instance address
0x30b7DCbefb27d99BA7971864A4B44014e4151759

Level address
0xb6c2Ec883DaAac76D8922519E63f875c2ec65575

player balance
"0.465648363418903234"

selfdestruct and boom!!!

# LEVEL 8 vault

Level address
0xB7257D8Ba61BD1b3Fb7249DCd9330a023a5F3670

Instance address
0xcd2a0041F9358A2Eb1a0D8760fD410EFa155EE67

player balance
"0.697408276793266748"

```
web3.eth.getStorageAt(addr, 1, console.log)
> null 0x412076657279207374726f6e67207365637265742070617373776f7264203a29

web3.utils.toAscii("0x412076657279207374726f6e67207365637265742070617373776f7264203a29")
'A very strong secret password :)'
```

# LEVEL 9 king

Level address
0x3049C00639E6dfC269ED1451764a046f7aE500c6

Instance address
0x3A9d2a76F10517F4fd19F9C194F993074A37985D

player balance
"0.694601001750528772"

exploit contract becomes king but has no recieve or fallback function breaking the recieve function in king contract

# LEVEL 10 reentrancy

Level address
0x2a24869323C0B13Dff24E196Ba072dC790D52479

Instance address
0x6Ac0bb2902E2835c1bA34DC25B07d16FcF901775

player balance
"0.37368723142969546"

Straightforward reentrancy attack.

# LEVEL 11 elevator

Level address
0x6DcE47e94Fa22F8E2d8A7FDf538602B1F86aBFd2

Instance address
0x4C073e8585B0d23e2d26e143165103888D1Ad4E0

player balance
"0.576235855849107553"

send false when function is first called and true when it is called again.

# LEVEL 12 privacy

Level address
0x131c3249e115491E83De375171767Af07906eA36

Instance address
0x2C33762f7c55AAC428C3abAA5F0c481cAE76852c

player balance
"0.793796152330119037"

```
// get the entry of data array at index 2.
await web3.eth.getStorageAt(contract.address, 5, console.log)
"0x14690fdf857625e4fe6f798d6ad3c7dbf82a6b1a6c9c082c0c6cfca4d394c4b1"

// convert 32 bytes to 16. (strip the last 16 bytes) and get the key

0x14690fdf857625e4fe6f798d6ad3c7db
```

# LEVEL 15 naught_coin

Level address
0x80934BE6B8B872B364b470Ca30EaAd8AEAC4f63F

Instance address
0xE045c339652a07Fc1d722102D5Da2d9248301881

player balance
"0.578042988607018875"

1. From main acc approve acc2 to be able to withdraw all tokens.
2. Use allowance function to verify approval.
3. From acc2 use transfer from function to withdraw all tokens.

# LEVEL 16 preservation

Level address
0x7ae0655F0Ee1e7752D7C62493CEa1E69A810e2ed

Instance address
0xAC2630210e92Df3E1E6D1B5183586CACa792A99c

player balance
"0.805343639382768933"

Unsafe delegate call use where it is possible to override variables of the contract. Once we can control the address of the contract it delegates to we can run our own code inside the contract. <br> **Smart contract version of RCE**.

# LEVEL 17 recovery

Level address
0xAF98ab8F2e2B24F42C661ed023237f5B7acAB048

Instance address
0xe473eF11db6be3F1bA29F3b8bc5B4e33D75E634f

player balance
"0.824283944847799029"

address for new contract in solidity by create opcode is computed by kecchak256(relp(sender, nonce)) <br>
Sender would be **instance address(0xe473eF11db6be3F1bA29F3b8bc5B4e33D75E634f for me)**

so using the sender we can generate possible addresses and find the lost address.
Once found just call self destruct to recover all eth inside contract.

# LEVEL 18 magic_number

Level address
0x2132C7bc11De7A90B87375f282d36100a29f97a9

Instance address
0x32dAd167A2C07d66277c9fD02F9EBf7f4672523d

player balance
"0.82786776088360826"

low level

# LEVEL 19 alien_codex

Level address
0x0BC04aa6aaC163A6B3667636D798FA053D43BD11

Instance address
0x071f4e01E04A5224538463387Db5212bB8775212

player balance
"0.800044824281606919"

Cause the Codex[] to underflow using retract function. then overwrite the owner state variable using revise function.

# LEVEL 20 denial

Level address
0x2427aF06f748A6adb651aCaB0cA8FbC7EaF802e6

Instance address
0x3DB9785BA3f01698A55051a861d1e443831c5316

player balance
"0.782412097021268429"

set receive function such that it consumes all gas.

# LEVEL 21 shop

Level address
0x691eeA9286124c043B82997201E805646b76351a

Instance address
0xAd8A4051cED7bbfA254d94631Ff6Df83Fbf5E901

player balance
"0.824283944847799029"

Just like the elevator but view functions cannot modify state variables hence gotta improvise and use conditionals to pass the if() check in buy function.

# LEVEL 22 dex

Level address
0xB468f8e42AC0fAe675B56bc6FDa9C0563B61A52F

Level address
0xB468f8e42AC0fAe675B56bc6FDa9C0563B61A52F

player balance
"1.025583389771486694"

## TEST1

spender - dexinstance
| mytokens(start) | 1 swap usd->inr | 2 swap | 3 swap |
| ----------------- | ---------------- | -------- | ------ |
| usd - 10 | 9 | 8 | 7 |
| inr - 10 | 11 | 11 | 11 |
| dextokens(start) |   |  |  |
| usd - 100 | 101 | 102 | 103 |
| inr - 100 | 99 | 99 | 99 |

swap price (1 swap usd->inr)->(2 swap)->(3 swap)
1 token -> 0 -> 0 -> 0
100 token -> 98 -> 97 -> 96
swap ammount 0 hence inr not increasing in above table.

swap price (1 swap inr->usd)->(2 swap)->(3 swap)
1 token -> _ -> _-> 1
100 token -> _ -> _-> 104

INCREASE THE `swap amount` TO DRAIN THE DEX CONTRACT.

so basically swap from token1 to token2 and then swap from token2 to token1 and vice versa, until you can empty tokens from dex contract.

# LEVEL 23 dextwo

Level address
0xf59112032D54862E199626F55cFad4F8a3b0Fce9

Instance address
0x64110DEc716F710A625ac7972910fcbcd26EeFb6

player balance
"0.797688290079701348"

Can I deploy my own tokens??? yeah.
Create Fake tokens and give dex2 just 10 so that 10 of fake 100 of dex2's.

# LEVEL 26 doubleentrypoint

Level address
0x34bD06F195756635a10A7018568E033bC15F3FB5

player balance
"0.800044824281606919"

### Vuln
LegacyToken can delegate to new contract so if legacy token delegates to DET, DET can be swept from vault simply by sweeeping address of legacy token in ```sweeptoken()``` function.

### Bot
We can monitor ```delegateTransfer``` function of doubleentrypoint contract as it contains a ```fortanotify``` modifier. 
Implement a bot that monitors if ```origSender``` from doubleentry point contract is set to address of cryptovault and trigger alert. 

